import argparse
import os
import subprocess
import sys
from argparse import RawTextHelpFormatter

HEADER_ = """
#ifndef CT_PARAMETER_H
#define CT_PARAMETER_H

#include "patch_base.cuh"

namespace CT
{
"""

FOOTER_ = """
} // namespace CT

#endif // CT_PARAMETER_H
"""

BUILD_DIR_ = os.path.abspath("@CMAKE_BINARY_DIR@")  # @...@ replaced by CMake
BUILD_INC_ = os.path.join(BUILD_DIR_, "include")
DEFAULT_OUTFILE_ = os.path.join(BUILD_INC_, "ct_parameter.h")


def parse_args():
    parser = argparse.ArgumentParser(
        description="""Create compile-time parameters.""",
        formatter_class=RawTextHelpFormatter,
    )
    parser.add_argument(
        "-O",
        "--output",
        help="output file of the compile-time parameters",
        type=argparse.FileType("w"),
        default=DEFAULT_OUTFILE_,
    )
    parser.add_argument(
        "-DIM",
        "--dimension",
        default=2,
        type=int,
        choices=[2, 3],
        help="spatial dimension of the domain",
    )
    parser.add_argument(
        "-DEG",
        "--fe-degree",
        default=1,
        type=int,
        choices=range(1, 11),
        help="spatial dimension of the domain",
    )
    parser.add_argument(
        "-N_STAGES",
        "--Nstages",
        default=2,
        type=int,
        choices=range(1, 11),
        help="IRK stages",
    )
    parser.add_argument(
        "-DT",
        "--timesize",
        default=0.1,
        type=float,
        help="time step size",
    )
    parser.add_argument(
        "-ENDT",
        "--endtime",
        default=0.5,
        type=float,
        help="end time",
    )
    parser.add_argument(
        "-REDUCE",
        "--reduce",
        default=1e-9,
        type=float,
        help="desired reduction factor for outer iteration",
    )
    parser.add_argument(
        "-REDUCE_INNER",
        "--reduce_inner",
        default=1e-6,
        type=float,
        help="desired reduction factor for inner iteration",
    )
    parser.add_argument(
        "-MAXIT",
        "--max_steps",
        default=20,
        type=int,
        help="maximum number of steps for outer iteration",
    )
    parser.add_argument(
        "-MAXIT_INNER",
        "--max_steps_inner",
        default=20,
        type=int,
        help="maximum number of steps for inner iteration",
    )
    parser.add_argument(
        "-MAXSIZE",
        "--max_sizes",
        default=5000000,
        type=int,
        help="maximum number of dofs",
    )
    parser.add_argument(
        "-DLY",
        "--dof-layout",
        default="Q",
        type=str,
        choices=["Q", "DGQ", "RT"],
        help="dof layout of finite element method",
    )
    parser.add_argument(
        "-LOG", "--log-directory", default=BUILD_DIR_, help="directory of the log file"
    )
    parser.add_argument(
        "-K",
        "--kernel_type",
        default="L",
        nargs="+",
        choices=[
            "GLOBAL",
            "SEPERATE",
            "FUSED_BASE",
            "FUSED_L",
            "FUSED_3D",
            "FUSED_CF",
            "FUSED_BD",
            "Exact",
            "NN",
            "Chebyshev",
        ],
        help="variant of the Schwarz smoother kernel",
    )
    parser.add_argument(
        "-G",
        "--granularity",
        default="multiple",
        choices=["none", "user_define", "multiple"],
        help="thread-block granularity scheme",
    )
    parser.add_argument(
        "-VNUM",
        "--vcycle_number",
        default="double",
        type=str,
        choices=["double", "float"],
        help="number type for the multigrid v-cycle",
    )
    parser.add_argument(
        "-SETS",
        "--test_sets",
        default="none",
        type=str,
        choices=["none", "kernel", "error_analysis", "vnum"],
        help="sets of experiments used for comparsion",
    )
    args = parser.parse_args()
    assert os.path.isdir(args.log_directory), "Invalid directory path: {}".format(
        args.log_directory
    )
    fpath = args.output.name
    assert os.path.isdir(os.path.dirname(fpath)), "Invalid output director: {}".format(
        os.path.dirname(fpath)
    )
    return args


def rawstr(string):
    return r'"' + string + r'"'


class Parameter:
    """Class containing the compile-time parameters."""

    def __init__(self):
        """generating default and parsed parameters"""
        options = parse_args()
        dim = options.dimension
        deg = options.fe_degree
        self.dimension = ("constexpr unsigned int", dim)
        self.fe_degree = ("constexpr unsigned int", deg)
        self.n_stages = ("constexpr unsigned int", options.Nstages)
        self.dt = ("constexpr double", options.timesize)
        self.endt = ("constexpr double", options.endtime)
        self.reduce = ("constexpr double", options.reduce)
        self.reduce_inner = ("constexpr double", options.reduce_inner)
        self.max_steps = ("constexpr unsigned int", options.max_steps)
        self.max_steps_inner = ("constexpr unsigned int", options.max_steps_inner)
        self.max_sizes = ("constexpr long long unsigned int", options.max_sizes)
        self.dof_layout = (
            "constexpr auto",
            "PSMF::DoFLayout::" + str(options.dof_layout),
        )
        self.vcycle_number = ("using", str(options.vcycle_number))
        self.log_dir = ("const std::string", rawstr(options.log_directory))
        self.sets = ("const std::string", rawstr(options.test_sets))
        self.smoother_prm(options.kernel_type)
        self.granularity_prm(options.granularity)

    def smoother_prm(self, variant):
        """translate the variant into parameters"""
        kernel_str = "{"
        count = 0
        for kernel in variant:
            if kernel.startswith("GLO"):
                kernel_str += r"PSMF::SmootherVariant::GLOBAL, "
                count += 1
            elif kernel.startswith("SEP"):
                kernel_str += r"PSMF::SmootherVariant::SEPERATE, "
                count += 1
            elif kernel.endswith("BASE"):
                kernel_str += r"PSMF::SmootherVariant::FUSED_BASE, "
                count += 1
            elif kernel.endswith("L"):
                kernel_str += r"PSMF::SmootherVariant::FUSED_L, "
                count += 1
            elif kernel.endswith("_3D"):
                kernel_str += r"PSMF::SmootherVariant::FUSED_3D, "
                count += 1
            elif kernel.endswith("CF"):
                kernel_str += r"PSMF::SmootherVariant::FUSED_CF, "
                count += 1
            elif kernel.endswith("_BD"):
                kernel_str += r"PSMF::SmootherVariant::FUSED_BD, "
                count += 1
            elif kernel.endswith("Exact"):
                kernel_str += r"PSMF::SmootherVariant::Exact, "
                count += 1
            elif kernel.endswith("NN"):
                kernel_str += r"PSMF::SmootherVariant::NN, "
                count += 1
            elif kernel.startswith("Cheb"):
                kernel_str += r"PSMF::SmootherVariant::Chebyshev, "
                count += 1
        self.kernel_type = (
            "constexpr std::array<PSMF::SmootherVariant, " + str(count) + ">",
            kernel_str + "}",
        )

    def granularity_prm(self, variant):
        """translate the variant into parameters"""
        if variant.startswith("n"):
            self.granularity = ("constexpr auto", r"PSMF::GranularityScheme::none")
        elif variant.startswith("u"):
            self.granularity = (
                "constexpr auto",
                r"PSMF::GranularityScheme::user_define",
            )
        elif variant.startswith("m"):
            self.granularity = ("constexpr auto", r"PSMF::GranularityScheme::multiple")


def assignf(name_, type_, value_):
    """formatted string defining a C-style assignment"""
    name = name_.upper() + "_"
    return "{} {} = {};".format(type_, name, value_)


def main():
    options = parse_args()
    ostream = options.output

    def oprint(*objects, **kwargs):
        """prints the output to the given output stream"""
        print(*objects, file=ostream, **kwargs)

    #: modify the parameters
    prm = Parameter()

    #: write header to output
    oprint(HEADER_, sep="\n")

    #: write variables to output
    def unpack_var(variables):
        """unpacks the variables into its name, type and value"""
        for name_ in variables:
            type_, value_ = variables[name_]
            yield name_, type_, value_

    variables = vars(prm)
    for name, vtype, value in unpack_var(variables):
        oprint(assignf(name, vtype, value), sep="\n")

    #: write footer to output
    oprint(FOOTER_, sep="\n")

    #: close the output stream
    if options.output:
        ostream.close()


if __name__ == "__main__":
    main()
